Index: main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n#include<bits/stdc++.h>\r\n\r\n#include <fstream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n//Files:\r\n//For Primary index -> PrimaryIndexAuthor , PrimaryIndexBook -> ( ID, offset)\r\n//For Secondary index -> SecondaryIndexAuthor ->(Name, Pointer)\r\n//                    -> SecondaryIndexBook ->(AuthorID, pointer)\r\n//For Linked List -> LLAuthor ->(#, ID(for author), Pointer)\r\n//                -> LLBook   ->(#, ID(for book), Pointer)\r\n\r\nstruct Author {\r\n    char authorID[15];\r\n    char authorName[30];\r\n    char address[30];\r\n};\r\n\r\nstruct Book {\r\n    char ISBN[15];\r\n    char bookTitle[30];\r\n    char authorID[30];\r\n};\r\n\r\n\r\n// Function declarations\r\nvoid insertAuthorPrimary(char id[], short offset);\r\nvoid insertBookPrimary(char id[], short offset);\r\nvoid insertAuthorName(char name[], char ID[]);\r\nvoid insertAuthorID(char authorID[], char ISBN[]);\r\nvoid addAuthor(Author author);\r\nvoid addBook(Book book);\r\n\r\n\r\nvoid deleteBookPrimary(char id[]);\r\nvoid deleteAuthorPrimary(char id[]);\r\nvoid deleteAuthorID(char authorID[]);\r\nvoid deleteAuthorName(char name[] , char ID[]);\r\nvoid deleteAuthor(char authorID[]);\r\nvoid deleteBook(char ISBN[]);\r\n\r\n\r\nint getAuthorByID(int id, fstream &indexFile); // search for the author by id\r\nint getBookByISBN(int isbn, fstream &indexFile); // search for the book by isbn\r\nvoid printAuthorByID(int offset); // print the author record by offset\r\nvoid printBookByISBN(int offset); // print the book record by offset\r\nvector<int> getBookByAuthorID(int id, fstream &secondaryIndexFile); // search for the books by author id and print the book records\r\nvoid printBookByAuthorID(const vector<int>& v); // print the book records\r\nvector<int> getAuthorByName(string name, fstream &secondaryIndexFile); // search for the authors by name and print the author records\r\nvoid printAuthorByName(const vector<int>& v); // print the author records\r\nvoid parseQuery(const string& query); // parse the query and call the appropriate function\r\n\r\nvoid updateAuthorNameByID(int id, string newName, fstream &indexFile); // search for the author by id and update the name\r\nvoid updateBookTitleByISBN(int isbn, string newTitle, fstream &indexFile); // search for the book by isbn and update the title\r\n\r\nint main() {\r\n    fstream AuthorFile(\"Author.txt\", ios::in | ios::out | ios::binary);\r\n    fstream BookFile(\"Book.txt\", ios::in | ios::out | ios::binary);\r\n    if (AuthorFile.tellg() == 0)\r\n        AuthorFile << -1 << endl;\r\n    if (BookFile.tellg() == 0)\r\n        BookFile << -1 << endl;\r\n    AuthorFile.close();\r\n    BookFile.close();\r\n\r\n    fstream PrimaryIndexAuthor(\"PrimaryIndexAuthor.txt\", ios::in | ios::out | ios::binary);\r\n    fstream PrimaryIndexBook(\"PrimaryIndexBook.txt\", ios::in | ios::out | ios::binary);\r\n    cout << \"Welcome\" << endl;\r\n    int option = 0;\r\n\r\n    while(option != 10){\r\n\r\n        cout << \"1- Add New Author\" << endl;\r\n        cout << \"2- Add New Book\" << endl;\r\n        cout << \"3- Update Author Name (Author ID)\" << endl;\r\n        cout << \"4- Update Book Title (ISBN)\" << endl;\r\n        cout << \"5- Delete Book (ISBN)\" << endl;\r\n        cout << \"6- Delete Author (Author ID)\" << endl;\r\n        cout << \"7- Print Author (Author ID)\" << endl;\r\n        cout << \"8- Print Book (ISBN)\" << endl;\r\n        cout << \"9- Write Query\" << endl;\r\n        cout << \"10- Exit\" << endl;\r\n\r\n        cout << \"Please enter your choice\" << endl;\r\n        cin >> option;\r\n\r\n        cin.ignore();\r\n        if(option == 1){\r\n            Author author;\r\n            cout << \"Please enter Author ID\" << endl;\r\n            cin >> author.authorID;\r\n            cout << \"Please enter Author Name\" << endl;\r\n            cin.ignore();\r\n            cin.getline(author.authorName , 30);\r\n            cout << \"Please enter Author Address\" << endl;\r\n//            cin.ignore();\r\n            cin.getline(author.address , 30);\r\n            addAuthor(author);\r\n        }\r\n        else if(option == 2){\r\n            Book book;\r\n            cout << \"Please enter Book ISBN\" << endl;\r\n            cin >> book.ISBN;\r\n            cout << \"Please enter Book Title\" << endl;\r\n            cin.ignore();\r\n            cin.getline(book.bookTitle , 30);\r\n            cout << \"Please enter Author ID\" << endl;\r\n            cin >> book.authorID;\r\n            addBook(book);\r\n        }\r\n        else if(option == 3){\r\n            int id;\r\n            string newName;\r\n            cout << \"Please enter Author ID\" << endl;\r\n            cin >> id;\r\n            cout << \"Please enter Author New Name\" << endl;\r\n            cin >> newName;\r\n            updateAuthorNameByID(id, newName, PrimaryIndexAuthor);\r\n        }\r\n        else if(option == 4){\r\n            int isbn;\r\n            string newTitle;\r\n            cout << \"Please enter Book ISBN\" << endl;\r\n            cin >> isbn;\r\n            cout << \"Please enter Book New Title\" << endl;\r\n            cin >> newTitle;\r\n            updateBookTitleByISBN(isbn, newTitle, PrimaryIndexBook);\r\n        }\r\n        else if(option == 5){\r\n            char isbn[15];\r\n            cout << \"Please enter Book ISBN\" << endl;\r\n            cin >> isbn;\r\n            deleteBook(isbn);\r\n        }\r\n        else if(option == 6){\r\n            char authorID[15];\r\n            cout << \"Please enter Author ID\" << endl;\r\n            cin >> authorID;\r\n            deleteAuthor(authorID);\r\n        }\r\n        else if(option == 7){\r\n            int id;\r\n            cout << \"Please enter Author ID\" << endl;\r\n            cin >> id;\r\n            printAuthorByID(getAuthorByID(id, PrimaryIndexAuthor));\r\n        }\r\n        else if(option == 8){\r\n            int isbn;\r\n            cout << \"Please enter Book ISBN\" << endl;\r\n            cin >> isbn;\r\n            printBookByISBN(getBookByISBN(isbn, PrimaryIndexBook));\r\n        }\r\n        else if(option == 9) {\r\n            string query;\r\n            cout << \"Please enter your query\" << endl;\r\n            cout << \"Available queries: \" << endl;\r\n            cout << \"Select all from Authors where Author ID= number;\" << endl;\r\n            cout << \"Select all from Books where Author ID= number;\" << endl;\r\n            cout << \"Select Author from Authors where Author Name= name;\" << endl;\r\n\r\n            getline(cin , query);\r\n            parseQuery(query);\r\n        }\r\n        else if(option == 10){\r\n            cout << \"Goodbye\" << endl;\r\n        }\r\n        else{\r\n            cout << \"Invalid Option\" << endl;\r\n        }\r\n\r\n    }\r\n//    parseQuery(\"Select all from Authors where Author ID= 88888;\");\r\n//    parseQuery(\"Select all from Authors where Author ID= 1;\");\r\n\r\n//    parseQuery(\"Select all from Books where Author ID= 1; \");\r\n//    parseQuery(\"Select all from Books where Author ID= 8888; \");\r\n\r\n//    parseQuery(\"Select Author from Authors where Author Name= Ali;\");\r\n//    parseQuery(\"Select Author from Authors where Author Name= Shady;\");\r\n//    printAuthorByID(4);\r\n//    printAuthorByID(68);\r\n//    printBookByISBN(25);\r\n//    printBookByISBN(4);\r\n\r\n//    fstream secondaryIndexFile(\"SecondaryIndexBook.txt\", ios::in | ios::out | ios::binary);\r\n//    printBookByAuthorID(getBookByAuthorID(1, secondaryIndexFile));\r\n\r\n//    fstream secondaryIndexFile2(\"SecondaryIndexAuthor.txt\", ios::in | ios::out | ios::binary);\r\n//    printAuthorByName(getAuthorByName(\"Ali\", secondaryIndexFile2));\r\n//    Author author = {\"1\", \"Ahmed\", \"Cairo\"};\r\n//    Author author2 = {\"2\", \"Mohamed\", \"Alex\"};\r\n//    Author author3 = {\"3\", \"Ali\", \"Giza\"};\r\n//    Author author4 = {\"4\", \"Mahmoud\", \"Aswan\"};\r\n//    Author author5 = {\"9\", \"Ali\", \"III\"};\r\n//    Author author = {\"55\", \"ab\", \"cd\"};\r\n////////\r\n//    addAuthor(author);\r\n//    addAuthor(author2);\r\n//    addAuthor(author3);\r\n//    addAuthor(author4);\r\n//    addAuthor(author5);\r\n//    addAuthor(author);\r\n\r\n//    deleteAuthor(\"1\");\r\n//    deleteAuthor(\"2\");\r\n//    deleteAuthor(\"3\");\r\n//    deleteAuthor(\"4\");\r\n//    deleteAuthor(\"9\");\r\n\r\n//    fstream indexFile(\"PrimaryIndexAuthor.txt\", ios::in | ios::out | ios::binary);\r\n//    updateAuthorNameByID(1, \"Sh\", indexFile);\r\n\r\n//    fstream indexFile2(\"PrimaryIndexBook.txt\", ios::in | ios::out | ios::binary);\r\n//    updateBookTitleByISBN(1, \"bb\", indexFile2);\r\n//\r\n//    Book book = {\"1\", \"C++\", \"1\"};\r\n//    Book book2 = {\"2\", \"Java\", \"2\"};\r\n//    Book book3 = {\"3\", \"Python\", \"3\"};\r\n//    Book book4 = {\"4\", \"C\", \"4\"};\r\n//\r\n//    addBook(book);\r\n//    addBook(book2);\r\n//    addBook(book3);\r\n//    addBook(book4);\r\n\r\n//    deleteBook(\"2\");\r\n//    deleteBook(\"4\");\r\n\r\n\r\n    return 0;\r\n}\r\n// A function that takes the authorID as a parameter and binary search for the authorID in the PrimaryIndexAuthor file\r\n// and get the offset of the author record then seek to the offset in the Author file and read the author record\r\nint getAuthorByID(int id, fstream &indexFile) {\r\n        // open the PrimaryIndexAuthor file in the read mode\r\n        // count the number of records in the PrimaryIndexAuthor file\r\n        int count = 0;\r\n        string line;\r\n        while (getline(indexFile, line))\r\n        {\r\n            count++;\r\n        }\r\n        // loop through the PrimaryIndexAuthor file\r\n        // and get each id and compare it with the id parameter\r\n        indexFile.clear();\r\n        indexFile.seekg(0, ios::beg);\r\n        // store records into a map to sort them\r\n        vector<pair<int, int>> records;\r\n        for(int i = 0; i < count; i++) {\r\n            if(getline(indexFile, line)) {\r\n                int currentID, currentOffset;\r\n                // before the space is the id\r\n                // after the space is the offset\r\n                currentID = stoi(line.substr(0, line.find(' ')));\r\n                currentOffset = stoi(line.substr(line.find(' ') + 1));\r\n                // insert the record into the map\r\n                records.emplace_back(currentID, currentOffset);\r\n            }\r\n        }\r\n        indexFile.close();\r\n\r\n        // binary search for the id\r\n        int left = 0, right = count-1, mid;\r\n        int offset = -1;\r\n        bool found = false;\r\n        while(left <= right) {\r\n            mid = left + (right - left) / 2;\r\n            if(records[mid].first == id) {\r\n                found = true;\r\n                offset = records[mid].second;\r\n                break;\r\n            }\r\n            else if (records[mid].first < id)\r\n            {\r\n                left = mid + 1;\r\n            }\r\n            else\r\n            {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n    return offset;\r\n}\r\nvoid printAuthorByID(int offset) {\r\n    if(offset == -1) {\r\n        cout << \"Author not found\" << endl;\r\n        return;\r\n    }\r\n    // open the Author file in the read mode\r\n    ifstream author(\"Author.txt\", ios:: binary);\r\n    // seek to the offset\r\n    author.seekg(offset, ios::beg);\r\n    // read the length of the author record\r\n    char length[3];\r\n    length[2] = '\\0';\r\n    author.read(length, 2);\r\n    // convert the length to integer\r\n    int len = stoi(length);\r\n    // read about len bytes from the current position\r\n    char* record = new char[len+1];\r\n    record[len] = '\\0';\r\n    author.read(record, len);\r\n    author.close();\r\n    // parse the record\r\n    stringstream ss(record);\r\n    string ID, name, address;\r\n    getline(ss, ID, '|');\r\n    getline(ss, name, '|');\r\n    getline(ss, address, '|');\r\n    cout << \"ID: \" << ID << \"\\nName: \"<< name << \"\\nAddress: \" << address << endl;\r\n}\r\n\r\n// A function that takes the ISBN as a parameter and binary search for the ISBN in the PrimaryIndexBook file\r\nint getBookByISBN(int isbn, fstream &indexFile) {\r\n    // count the number of records in the PrimaryIndexBook file\r\n    int count = 0;\r\n    string line;\r\n    while (getline(indexFile, line))\r\n    {\r\n        count++;\r\n    }\r\n    // loop through the PrimaryIndexAuthor file\r\n    // and get each id and compare it with the id parameter\r\n    indexFile.clear();\r\n    indexFile.seekg(0, ios::beg);\r\n    // store records into a vector to sort them\r\n    vector<pair<int, int>> records;\r\n    for(int i = 0; i < count; i++) {\r\n        if (getline(indexFile, line)) {\r\n            int currentISBN, currentOffset;\r\n            string temp = line.substr(0, line.find(' '));\r\n            string temp2 = line.substr(line.find(' ') + 1);\r\n\r\n            try {\r\n                currentISBN = stoi(temp);\r\n                currentOffset = stoi(temp2);\r\n                records.emplace_back(currentISBN, currentOffset);\r\n            } catch (const std::exception& e) {\r\n                cerr << \"Error converting line \" << i + 1 << \": \" << e.what() << endl;\r\n                // Handle or skip this line as needed\r\n                continue; // Skip to the next iteration\r\n            }\r\n        }\r\n    }\r\n    indexFile.close();\r\n\r\n    // binary search for the id\r\n    int left = 0, right = count-1, mid;\r\n    int offset = -1;\r\n    while(left <= right) {\r\n        mid = left + (right - left) / 2;\r\n        if(records[mid].first == isbn) {\r\n            offset = records[mid].second;\r\n            break;\r\n        }\r\n        else if (records[mid].first < isbn)\r\n        {\r\n            left = mid + 1;\r\n        }\r\n        else\r\n        {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n    return offset;\r\n}\r\nvoid printBookByISBN(int offset) {\r\n    if(offset == -1) {\r\n        cout << \"Book not found\" << endl;\r\n        return;\r\n    }\r\n    // open the Author file in the read mode\r\n    ifstream book(\"Book.txt\", ios:: binary);\r\n    // seek to the offset\r\n    book.seekg(offset, ios::beg);\r\n    // read the length of the author record\r\n    char length[3];\r\n    length[2] = '\\0';\r\n    book.read(length, 2);\r\n    // convert the length to integer\r\n    int len = stoi(length);\r\n    // read about len bytes from the current position\r\n    char* record = new char[len+1];\r\n    record[len] = '\\0';\r\n    book.read(record, len);\r\n    book.close();\r\n    // parse the record\r\n    stringstream ss(record);\r\n    string ISBN, title, authorID;\r\n    getline(ss, ISBN, '|');\r\n    getline(ss, title, '|');\r\n    getline(ss, authorID, '|');\r\n    cout << \"ISBN: \" << ISBN << \"\\nBook Title: \" << title << \"\\nAuthor ID: \" << authorID << endl;\r\n}\r\nvector<int> getBookByAuthorID(int id, fstream &secondaryIndexFile) {\r\n    // open the secondaryIndexFile\r\n    // count the number of records in the secondaryIndexFile\r\n    int count = 0;\r\n    string line;\r\n    while (getline(secondaryIndexFile, line))\r\n    {\r\n        count++;\r\n    }\r\n    secondaryIndexFile.clear();\r\n    secondaryIndexFile.seekg(0, ios::beg);\r\n    // store records of the secondary index file into a vector\r\n    vector<pair<int, int>> records;\r\n    for(int i = 0; i < count; i++) {\r\n        if (getline(secondaryIndexFile, line)) {\r\n            int currentID, currentPointer;\r\n            string temp = line.substr(0, line.find(' '));\r\n            string temp2 = line.substr(line.find(' ') + 1);\r\n\r\n            try {\r\n                currentID = stoi(temp);\r\n                currentPointer = stoi(temp2);\r\n                records.emplace_back(currentID, currentPointer);\r\n            }\r\n            catch (const std::exception& e) {\r\n                cerr << \"Error converting line \" << i + 1 << \": \" << e.what() << endl;\r\n                // Handle or skip this line as needed\r\n                continue; // Skip to the next iteration\r\n            }\r\n        }\r\n    }\r\n    // count the number of records in the linked list\r\n    fstream linkedListFile(\"LLBook.txt\", ios::in);\r\n    int linkedListCount = 0;\r\n    string line2;\r\n    while (getline(linkedListFile, line2))\r\n    {\r\n        linkedListCount++;\r\n    }\r\n    // store the linked list in a vector of tuples\r\n    vector<tuple<int, int, int>> linkedList;\r\n\r\n    linkedListFile.clear();\r\n    linkedListFile.seekg(0, ios::beg);\r\n\r\n    for(int i = 0; i < linkedListCount; i++) {\r\n        if (getline(linkedListFile, line2)) {\r\n            int currentHashValue, currentISBN, currentPointer;\r\n            string temp1 = line2.substr(0, line2.find(' '));\r\n            string temp2 = line2.substr(line2.find(' ') + 1);\r\n            string temp3 = temp2.substr(temp2.find(' ') + 1);\r\n\r\n            try {\r\n                currentHashValue = stoi(temp1);\r\n                currentISBN = stoi(temp2);\r\n                currentPointer = stoi(temp3);\r\n                linkedList.emplace_back(currentHashValue, currentISBN, currentPointer);\r\n            } catch (const std::exception& e) {\r\n                cerr << \"Error converting line \" << i + 1 << \": \" << e.what() << endl;\r\n                // Handle or skip this line as needed\r\n                continue; // Skip to the next iteration\r\n            }\r\n        }\r\n    }\r\n\r\n    // 1- binary search for the id to get the hash value\r\n    int left = 0, right = count-1, mid;\r\n    int hashValue = -1;\r\n    while(left <= right) {\r\n        mid = left + (right - left) / 2;\r\n        if(records[mid].first == id) {\r\n            hashValue = records[mid].second;\r\n            break;\r\n        }\r\n        else if (records[mid].first < id)\r\n        {\r\n            left = mid + 1;\r\n        }\r\n        else\r\n        {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n    // if the author is not found return empty vector\r\n    if(hashValue == -1) {\r\n        cout << \"Author is NOT found!\" << endl;\r\n        return {};\r\n    }\r\n    // 2- binary search on the linked list to get all the books\r\n    int pointer = hashValue;\r\n    left = 0, right = linkedListCount-1;\r\n    vector<int> ISBNs;\r\n    while(pointer != -1) {\r\n        while(left <= right) {\r\n            mid = left + (right - left) / 2;\r\n            if(get<0>(linkedList[mid]) == pointer) {\r\n                ISBNs.push_back(get<1>(linkedList[mid]));\r\n                pointer = get<2>(linkedList[mid]);\r\n                break;\r\n            }\r\n            else if (get<0>(linkedList[mid]) < pointer)\r\n            {\r\n                left = mid + 1;\r\n            }\r\n            else\r\n            {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n    }\r\n    return ISBNs;\r\n}\r\nvoid printBookByAuthorID(const vector<int>& v) {\r\n    // 3- print all the books\r\n    for(int i = 0; i < v.size(); i++) {\r\n        fstream primaryIndexFile(\"PrimaryIndexBook.txt\", ios::in | ios::binary);\r\n        int offset = getBookByISBN(v[i], primaryIndexFile);\r\n        printBookByISBN(offset);\r\n        primaryIndexFile.close();\r\n    }\r\n}\r\nvector<int> getAuthorByName(string name, fstream &secondaryIndexFile) {\r\n    // count the number of records in the secondaryIndexFile\r\n    int count = 0;\r\n    string line;\r\n    while (getline(secondaryIndexFile, line))\r\n    {\r\n        count++;\r\n    }\r\n    secondaryIndexFile.clear();\r\n    secondaryIndexFile.seekg(0, ios::beg);\r\n\r\n    // store records of the secondary index file into a vector\r\n    vector<pair<string, int>> records;\r\n    // convert the hash value to integer\r\n    for(int i = 0; i < count; i++) {\r\n        if (getline(secondaryIndexFile, line)) {\r\n            int hashValue;\r\n            string Name = line.substr(0, line.find(' '));\r\n            string temp = line.substr(line.find(' ') + 1);\r\n            try {\r\n                hashValue = stoi(temp);\r\n                records.emplace_back(Name, hashValue);\r\n            }\r\n            catch (const std::exception& e) {\r\n                cerr << \"Error converting line \" << i + 1 << \": \" << e.what() << endl;\r\n                // Handle or skip this line as needed\r\n                continue; // Skip to the next iteration\r\n            }\r\n        }\r\n    }\r\n    // count the number of records in the linked list\r\n    fstream linkedListFile(\"LLAuthor.txt\", ios::in);\r\n    int linkedListCount = 0;\r\n    string line2;\r\n    while (getline(linkedListFile, line2))\r\n    {\r\n        linkedListCount++;\r\n    }\r\n\r\n    linkedListFile.clear();\r\n    linkedListFile.seekg(0, ios::beg);\r\n    // store the linked list in a vector of tuples\r\n    vector<tuple<int, int, int>> linkedList;\r\n    for(int i = 0; i < linkedListCount; i++) {\r\n        if (getline(linkedListFile, line2)) {\r\n            int currentHashValue, currentID, currentPointer;\r\n            string temp1 = line2.substr(0, line2.find(' '));\r\n            string temp2 = line2.substr(line2.find(' ') + 1);\r\n            string temp3 = temp2.substr(temp2.find(' ') + 1);\r\n            try {\r\n                currentHashValue = stoi(temp1);\r\n                currentID = stoi(temp2);\r\n                currentPointer = stoi(temp3);\r\n                linkedList.emplace_back(currentHashValue, currentID, currentPointer);\r\n            } catch (const std::exception& e) {\r\n                cerr << \"Error converting line \" << i + 1 << \": \" << e.what() << endl;\r\n                // Handle or skip this line as needed\r\n                continue; // Skip to the next iteration\r\n            }\r\n        }\r\n    }\r\n    // 1- binary search for the name to get the hash value\r\n    int left = 0, right = count-1, mid;\r\n    int hashValue = -1;\r\n    while(left <= right) {\r\n        mid = left + (right - left) / 2;\r\n        if(records[mid].first == name) {\r\n            hashValue = records[mid].second;\r\n            break;\r\n        }\r\n        else if (records[mid].first < name)\r\n        {\r\n            left = mid + 1;\r\n        }\r\n        else\r\n        {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n    // if the author is not found return empty vector\r\n    if(hashValue == -1) {\r\n        cout << \"Author is NOT found!\" << endl;\r\n        return {};\r\n    }\r\n    // 2- binary search on the linked list to get all the authors of the same name\r\n    int pointer = hashValue;\r\n    vector<int> AuthorIDs;\r\n    while(pointer != -1) {\r\n        left = 0, right = linkedListCount-1;\r\n        while(left <= right) {\r\n            mid = left + (right - left) / 2;\r\n            if(get<0>(linkedList[mid]) == pointer) {\r\n                AuthorIDs.push_back(get<1>(linkedList[mid]));\r\n                pointer = get<2>(linkedList[mid]);\r\n                break;\r\n            }\r\n            else if (get<0>(linkedList[mid]) < pointer)\r\n            {\r\n                left = mid + 1;\r\n            }\r\n            else\r\n            {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n    }\r\n    return AuthorIDs;\r\n}\r\nvoid printAuthorByName(const vector<int>& v) {\r\n    // 3- print all the Author records\r\n    for(int i = 0; i < v.size(); i++) {\r\n        fstream primaryIndexFile(\"PrimaryIndexAuthor.txt\", ios::in | ios::binary);\r\n        int offset = getAuthorByID(v[i], primaryIndexFile);\r\n        printAuthorByID(offset);\r\n        primaryIndexFile.close();\r\n        cout << endl;\r\n    }\r\n}\r\nvoid parseQuery(const string& query) {\r\n    // Select all from Authors where Author ID= number;\r\n    if(query.find(\"Select all from Authors where Author ID=\") != string::npos) {\r\n        string temp = query.substr(query.find('=') + 1);\r\n        try {\r\n            int ID = stoi(temp);\r\n            fstream primaryIndexFile(\"PrimaryIndexAuthor.txt\", ios::in | ios::binary);\r\n            int offset = getAuthorByID(ID, primaryIndexFile);\r\n            printAuthorByID(offset);\r\n            primaryIndexFile.close();\r\n        }\r\n        catch (const std::exception& e) {\r\n            cerr << \"Error converting line \" << \": \" << e.what() << endl;\r\n            // Handle or skip this line as needed\r\n        }\r\n    }\r\n    // Select all from Books where Author ID= number;\r\n    else if(query.find(\"Select all from Books where Author ID=\") != string::npos) {\r\n        string temp = query.substr(query.find('=') + 1);\r\n        try {\r\n            int ID = stoi(temp);\r\n            fstream secondaryIndexFile(\"SecondaryIndexBook.txt\", ios::in | ios::binary);\r\n            vector<int> ISBNs = getBookByAuthorID(ID, secondaryIndexFile);\r\n            printBookByAuthorID(ISBNs);\r\n            secondaryIndexFile.close();\r\n        }\r\n        catch (const std::exception& e) {\r\n            cerr << \"Error converting line \" << \": \" << e.what() << endl;\r\n            // Handle or skip this line as needed\r\n        }\r\n    }\r\n    // Select Author from Authors where Author Name= name;\r\n    else if(query.find(\"Select Author from Authors where Author Name=\") != string::npos) {\r\n        string name = query.substr(query.find('=') + 2);\r\n        // remove the last \";\"\r\n        name = name.substr(0, name.size() - 1);\r\n        fstream secondaryIndexFile(\"SecondaryIndexAuthor.txt\", ios::in | ios::binary);\r\n        vector<int> IDs = getAuthorByName(name, secondaryIndexFile);\r\n        printAuthorByName(IDs);\r\n        secondaryIndexFile.close();\r\n    }\r\n    else {\r\n        cout << \"Invalid query!\" << endl;\r\n    }\r\n}\r\n/**\r\n * Inserts a new record into the primary index file for authors.\r\n *\r\n * @param id The ID of the author to be inserted\r\n * @param offset The offset of the author record\r\n */\r\nvoid insertAuthorPrimary(char id[], short offset) {\r\n    int x = atoi(id);\r\n\r\n    // Read all records\r\n    vector<pair<int, short>> records;\r\n\r\n    ifstream readPrimary(\"PrimaryIndexAuthor.txt\");\r\n    int tmp;\r\n    short of;\r\n\r\n    while (readPrimary >> tmp >> of) {\r\n        records.push_back(make_pair(tmp, of));\r\n    }\r\n\r\n    readPrimary.close();\r\n\r\n    // Insert the new record into the correct position\r\n    auto it = records.begin();\r\n    while (it != records.end() && it->first < x) {\r\n        ++it;\r\n    }\r\n\r\n    records.insert(it, make_pair(x, offset));\r\n\r\n    // Rewrite all records into the file in sorted order\r\n    ofstream writePrimary(\"PrimaryIndexAuthor.txt\", ios::trunc);\r\n\r\n    for (const auto& record : records) {\r\n        writePrimary << record.first << ' ' << record.second << '\\n';\r\n    }\r\n\r\n    writePrimary.close();\r\n}\r\n/**\r\n * Inserts a new record into the primary index file for books.\r\n *\r\n * @param id The ID of the book to be inserted\r\n * @param offset The offset of the book record\r\n */\r\nvoid insertBookPrimary(char id[], short offset){\r\n    int x = atoi(id);\r\n\r\n    // Read all records\r\n    vector<pair<int, short>> records;\r\n\r\n    ifstream readPrimary(\"PrimaryIndexBook.txt\");\r\n    int tmp;\r\n    short of;\r\n\r\n    while (readPrimary >> tmp >> of) {\r\n        records.push_back(make_pair(tmp, of));\r\n    }\r\n\r\n    readPrimary.close();\r\n\r\n    // Insert the new record into the correct position\r\n    auto it = records.begin();\r\n    while (it != records.end() && it->first < x) {\r\n        ++it;\r\n    }\r\n\r\n    records.insert(it, make_pair(x, offset));\r\n\r\n    // Rewrite all records into the file in sorted order\r\n    ofstream writePrimary(\"PrimaryIndexBook.txt\", ios::trunc);\r\n\r\n    for (const auto& record : records) {\r\n        writePrimary << record.first << ' ' << record.second << '\\n';\r\n    }\r\n\r\n    writePrimary.close();\r\n}\r\n/**\r\n * Inserts a new record into the linked list and secondary index files for authors.\r\n *\r\n * @param name The name of the author to be inserted\r\n * @param ID The ID of the author\r\n */\r\n\r\nvoid insertAuthorName(char name[], char ID[]) {\r\n    vector<pair<string, string>> data;\r\n    ifstream file(\"SecondaryIndexAuthor.txt\", ios::ate);\r\n\r\n    // Check if the file is empty\r\n    if (file.tellg() == 0) {\r\n        // If file is empty, create and write initial records\r\n        ofstream secFile(\"SecondaryIndexAuthor.txt\");\r\n        secFile << name << ' ' << 0 << '\\n';\r\n        secFile.close();\r\n\r\n        ofstream llFile(\"LLAuthor.txt\");\r\n        llFile << 0 << ' ' << ID << ' ' << -1 << '\\n';\r\n        llFile.close();\r\n    } else {\r\n        // File not empty, read and process records\r\n        ifstream secFile(\"SecondaryIndexAuthor.txt\");\r\n        ifstream llFile(\"LLAuthor.txt\");\r\n        string n, id;\r\n        int secPointer, llPointer, x;\r\n\r\n        // Loop through records in SecondaryIndexAuthor.txt\r\n        while (secFile >> n >> secPointer) {\r\n            llFile.clear();\r\n            llFile.seekg(0, ios::beg);\r\n\r\n            // Match found in SecondaryIndexAuthor.txt\r\n            while (llFile >> llPointer >> id >> x) {\r\n                if (secPointer == llPointer) {\r\n                    data.push_back(make_pair(n, id));\r\n\r\n                    // If x is not -1, continue pushing IDs until x is -1\r\n                    while (x != -1) {\r\n                        llFile >> llPointer >> id >> x;\r\n                        data.push_back(make_pair(n, id));\r\n                    }\r\n\r\n                    break; // Stop after processing IDs with x = -1\r\n                }\r\n            }\r\n        }\r\n\r\n        secFile.close();\r\n        llFile.close();\r\n\r\n        // Add the new name and ID\r\n        data.push_back(make_pair(name, ID));\r\n\r\n        // Define a lambda comparator to sort based on pair.first\r\n        auto compareFirst = [](const auto& a, const auto& b) {\r\n            return a.first < b.first;\r\n        };\r\n        // Sort the vector based on pair.first\r\n        sort(data.begin(), data.end(), compareFirst);\r\n\r\n        // Write sorted data back to files\r\n        ofstream secFile1(\"SecondaryIndexAuthor.txt\", ios::trunc);\r\n        ofstream llFile1(\"LLAuthor.txt\", ios::trunc);\r\n\r\n        // Write to SecondaryIndexAuthor.txt and LLAuthor.txt\r\n        for (int i = 0; i < data.size(); ++i) {\r\n            if (i == 0 || data[i].first != data[i - 1].first)\r\n                secFile1 << data[i].first << ' ' << i << '\\n';\r\n\r\n            if (data[i].first == data[i + 1].first)\r\n                llFile1 << i << ' ' << data[i].second << ' ' << i + 1 << '\\n';\r\n            else\r\n                llFile1 << i << ' ' << data[i].second << ' ' << -1 << '\\n';\r\n        }\r\n    }\r\n}\r\n/**\r\n * Inserts a new record into the linked list and secondary index files for books.\r\n *\r\n * @param authorID The ID of the author to be inserted\r\n * @param ISBN The ISBN of the book associated with the author\r\n */\r\n\r\nvoid insertAuthorID(char authorID[], char ISBN[]) {\r\n    vector<pair<string, string>> data;\r\n    ifstream file(\"SecondaryIndexBook.txt\", ios::ate);\r\n\r\n    // Check if the file is empty\r\n    if (file.tellg() == 0) {\r\n        // If file is empty, create and write initial records\r\n        ofstream secFile(\"SecondaryIndexBook.txt\");\r\n        secFile << authorID << ' ' << 0 << '\\n';\r\n        secFile.close();\r\n\r\n        ofstream llFile(\"LLBook.txt\");\r\n        llFile << 0 << ' ' << ISBN << ' ' << -1 << '\\n';\r\n        llFile.close();\r\n    } else {\r\n        // File not empty, read and process records\r\n        ifstream secFile(\"SecondaryIndexBook.txt\");\r\n        ifstream llFile(\"LLBook.txt\");\r\n        string autID, isbn;\r\n        int secPointer, llPointer, x;\r\n\r\n        // Loop through records in SecondaryIndexAuthor.txt\r\n        while (secFile >> autID >> secPointer) {\r\n            llFile.clear();\r\n            llFile.seekg(0, ios::beg);\r\n\r\n            // Match found in SecondaryIndexAuthor.txt\r\n            while (llFile >> llPointer >> isbn >> x) {\r\n                if (secPointer == llPointer) {\r\n                    data.push_back(make_pair(autID, isbn));\r\n\r\n                    // If x is not -1, continue pushing IDs until x is -1\r\n                    while (x != -1) {\r\n                        llFile >> llPointer >> isbn >> x;\r\n                        data.push_back(make_pair(autID, isbn));\r\n                    }\r\n\r\n                    break; // Stop after processing IDs with x = -1\r\n                }\r\n            }\r\n        }\r\n\r\n        secFile.close();\r\n        llFile.close();\r\n\r\n        // Add the new name and ID\r\n        data.push_back(make_pair(authorID, ISBN));\r\n\r\n        // Define a lambda comparator to sort based on pair.first\r\n        auto compareFirst = [](const auto& a, const auto& b) {\r\n            return a.first < b.first;\r\n        };\r\n        // Sort the vector based on pair.first\r\n        sort(data.begin(), data.end(), compareFirst);\r\n\r\n        // Write sorted data back to files\r\n        ofstream secFile1(\"SecondaryIndexBook.txt\", ios::trunc);\r\n        ofstream llFile1(\"LLBook.txt\", ios::trunc);\r\n\r\n        // Write to SecondaryIndexBook.txt and LLBook.txt\r\n        for (int i = 0; i < data.size(); ++i) {\r\n            if (i == 0 || data[i].first != data[i - 1].first)\r\n                secFile1 << data[i].first << ' ' << i << '\\n';\r\n\r\n            if (data[i].first == data[i + 1].first)\r\n                llFile1 << i << ' ' << data[i].second << ' ' << i + 1 << '\\n';\r\n            else\r\n                llFile1 << i << ' ' << data[i].second << ' ' << -1 << '\\n';\r\n        }\r\n\r\n    }\r\n}\r\n/**\r\n * Function to format a number into a two-byte string.\r\n * For example, if number is 1, it will be formatted as \"01\".\r\n *\r\n * @param number The number to be formatted.\r\n * @return The formatted string representing the number.\r\n */\r\nstring formatTwoBytes(int number) {\r\n    ostringstream oss;\r\n    oss << setw(2) << setfill('0') << number;\r\n    return oss.str();\r\n}\r\n\r\n/**\r\n * Function to add a new author record to the \"Author.txt\" file.\r\n *\r\n * @param author The Author object containing author information.\r\n */\r\nvoid addAuthor(Author author) {\r\n\r\n    //check if ID already exist\r\n    fstream primary(\"PrimaryIndexAuthor.txt\");\r\n\r\n    int x = atoi(author.authorID);\r\n    if (getAuthorByID(x , primary) != -1) {\r\n        cout << \"ID already exists!\" << endl;\r\n        return;\r\n    }\r\n\r\n    primary.close();\r\n\r\n    // Opening the file in read/write mode\r\n    fstream file(\"Author.txt\", ios::in | ios::out);\r\n\r\n    string header;\r\n    string line;\r\n\r\n    // Reading the first two lines from the file\r\n    for (int i = 0; i < 2; ++i) {\r\n        if (i == 0)\r\n            file >> header; // Reading header\r\n        else\r\n            file >> line; // Reading the second line\r\n    }\r\n\r\n    file.close(); // Closing the file after reading\r\n\r\n    // Calculating the size of the record to be added\r\n    int recordSize = strlen(author.authorID) + strlen(author.authorName) + strlen(author.address) + 3;\r\n    string recSize = formatTwoBytes(recordSize); // Formatting the size as a two-byte string\r\n\r\n    // Reopening the file in read/write/binary mode\r\n    file.open(\"Author.txt\", ios::out | ios::in | ios::binary);\r\n\r\n    // Checking if there are no deleted records\r\n    if (header == \"-1\") {\r\n        // No deleted records found, so appending the new record to the end of the file\r\n        file.seekp(0, ios::end);\r\n\r\n        insertAuthorPrimary(author.authorID, file.tellp()); // -> Add to primary index file\r\n        insertAuthorName(author.authorName, author.authorID); // -> Add to secondary file\r\n\r\n        file << recSize << author.authorID << '|' << author.authorName << '|' << author.address << '|';\r\n        file.close();\r\n        cout << \"The record is added successfully!\" << endl;\r\n    } else {\r\n        int currentOffset = stoi(header);\r\n        int count = 0;\r\n        while (true) {\r\n            int offset;\r\n            // Loop to search for space in the file to add the new record\r\n            //stringstream data(line);\r\n            file.seekg(currentOffset + 1); // Skip the '#'\r\n\r\n            string prevOffset;\r\n            char ch;\r\n            while (file.get(ch) && ch != '|')\r\n                prevOffset += ch;\r\n\r\n            string size;\r\n            while (file.get(ch) && ch != '|')\r\n                size += ch;\r\n\r\n            // If there is enough space at the current position to insert the new record\r\n            if (stoi(size) == (recordSize)) {\r\n\r\n                if(count == 0){ //if insert in last deleted record\r\n                    file.seekp(0);\r\n                    file << prevOffset;\r\n                }else{\r\n                    file.seekp(offset + 1);\r\n                    file << prevOffset;\r\n                }\r\n\r\n                file.seekp(currentOffset);\r\n\r\n                insertAuthorPrimary(author.authorID, file.tellp()); // -> Add to primary index file\r\n                insertAuthorName(author.authorName, author.authorID); // -> Add to secondary file\r\n\r\n                file << recSize << author.authorID << '|' << author.authorName << '|' << author.address << '|';\r\n\r\n                file.close();\r\n                cout << \"The record is added successfully!\" << endl;\r\n                return;\r\n            } else if (stoi(size) > (recordSize)) {\r\n\r\n                if(count == 0){ //if insert in last deleted record\r\n                    file.seekp(0);\r\n                    file << prevOffset;\r\n                }else{\r\n                    file.seekp(offset + 1);\r\n                    file << prevOffset;\r\n                }\r\n                // If the available space is larger than needed, insert the new record and fill the remaining space with '#'\r\n                file.seekp(currentOffset);\r\n\r\n                insertAuthorPrimary(author.authorID, file.tellp()); // -> Add to primary index file\r\n                insertAuthorName(author.authorName, author.authorID); // -> Add to secondary file\r\n\r\n                file << recSize << author.authorID << '|' << author.authorName << '|' << author.address << '|';\r\n\r\n                string rest = string(stoi(size) - recordSize , '#');\r\n                file << rest;\r\n\r\n                file.close();\r\n                cout << \"The record is added successfully!\" << endl;\r\n                return;\r\n            } else {\r\n                offset = currentOffset;\r\n                currentOffset = stoi(prevOffset);\r\n\r\n                count++;\r\n            }\r\n            if (stoi(prevOffset) == -1) {\r\n                // If no suitable space is found, append the new record to the end of the file\r\n                file.seekp(0, ios::end);\r\n\r\n                insertAuthorPrimary(author.authorID, file.tellp()); // -> Add to primary index file\r\n                insertAuthorName(author.authorName, author.authorID); // -> Add to secondary file\r\n\r\n                file << recSize << author.authorID << '|' << author.authorName << '|' << author.address << '|';\r\n\r\n                file.close();\r\n                cout << \"The record is added successfully!\" << endl;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Function to add a new book record to the \"Book.txt\" file.\r\n *\r\n * @param book The Book object containing book information.\r\n */\r\nvoid addBook(Book book) {\r\n\r\n    //check if ISBN already exist\r\n    fstream primary(\"PrimaryIndexBook.txt\");\r\n    int x = atoi(book.ISBN);\r\n    if (getBookByISBN(x , primary) != -1) {\r\n        cout << \"ISBN already exists!\" << endl;\r\n        return;\r\n    }\r\n\r\n    primary.close();\r\n\r\n    // Opening the file in read/write mode\r\n    fstream file(\"Book.txt\", ios::in | ios::out);\r\n\r\n    string header;\r\n    string line;\r\n\r\n    // Reading the first two lines from the file\r\n    for (int i = 0; i < 2; ++i) {\r\n        if (i == 0)\r\n            file >> header; // Reading header\r\n        else\r\n            file >> line; // Reading the second line\r\n    }\r\n\r\n    file.close(); // Closing the file after reading\r\n\r\n    // Calculating the size of the record to be added\r\n    int recordSize = strlen(book.ISBN) + strlen(book.bookTitle) + strlen(book.authorID) + 3;\r\n    string recSize = formatTwoBytes(recordSize); // Formatting the size as a two-byte string\r\n\r\n    // Reopening the file in read/write/binary mode\r\n    file.open(\"Book.txt\", ios::out | ios::in | ios::binary);\r\n\r\n    // Checking if there are no deleted records\r\n    if (header == \"-1\") {\r\n        // No deleted records found, so appending the new record to the end of the file\r\n        file.seekp(0, ios::end);\r\n\r\n        insertBookPrimary(book.ISBN, file.tellp()); // -> Add to primary index file\r\n        insertAuthorID(book.authorID, book.ISBN); // -> Add to secondary file\r\n\r\n        file << recSize << book.ISBN << '|' << book.bookTitle << '|' << book.authorID << '|';\r\n        file.close();\r\n        cout << \"The record is added successfully!\" << endl;\r\n\r\n\r\n    } else {\r\n        int currentOffset = stoi(header);\r\n        int count = 0;\r\n        while (true) {\r\n            int offset;\r\n            // Loop to search for space in the file to add the new record\r\n            //stringstream data(line);\r\n            file.seekg(currentOffset + 1); // Skip the '#'\r\n\r\n            string prevOffset;\r\n            char ch;\r\n            while (file.get(ch) && ch != '|')\r\n                prevOffset += ch;\r\n\r\n            string size;\r\n            while (file.get(ch) && ch != '|')\r\n                size += ch;\r\n\r\n            // If there is enough space at the current position to insert the new record\r\n            if (stoi(size) == (recordSize )) {\r\n\r\n                if(count == 0){ //if insert in last deleted record\r\n                    file.seekp(0);\r\n                    file << prevOffset;\r\n                }else{\r\n                    file.seekp(offset + 1);\r\n                    file << prevOffset;\r\n                }\r\n\r\n                file.seekp(currentOffset);\r\n\r\n                insertBookPrimary(book.ISBN, file.tellp()); // -> Add to primary index file\r\n                insertAuthorID(book.authorID, book.ISBN); // -> Add to secondary file\r\n\r\n                file << recSize << book.ISBN << '|' << book.bookTitle << '|' << book.authorID << '|';\r\n\r\n                file.close();\r\n                cout << \"The record is added successfully!\" << endl;\r\n                return;\r\n            } else if (stoi(size) > (recordSize )) {\r\n\r\n                if(count == 0){ //if insert in last deleted record\r\n                    file.seekp(0);\r\n                    file << prevOffset;\r\n                }else{\r\n                    file.seekp(offset + 1);\r\n                    file << prevOffset;\r\n                }\r\n                // If the available space is larger than needed, insert the new record and fill the remaining space with '#'\r\n                file.seekp(currentOffset);\r\n\r\n                insertBookPrimary(book.ISBN, file.tellp()); // -> Add to primary index file\r\n                insertAuthorID(book.authorID, book.ISBN); // -> Add to secondary file\r\n\r\n                file << recSize << book.ISBN << '|' << book.bookTitle << '|' << book.authorID << '|';\r\n\r\n                string rest = string(stoi(size) - recordSize , '#');\r\n                file << rest;\r\n\r\n                file.close();\r\n                cout << \"The record is added successfully!\" << endl;\r\n                return;\r\n            } else {\r\n                offset = currentOffset;\r\n                currentOffset = stoi(prevOffset);\r\n\r\n                count++;\r\n            }\r\n            if (stoi(prevOffset) == -1) {\r\n                // If no suitable space is found, append the new record to the end of the file\r\n                file.seekp(0, ios::end);\r\n\r\n                insertBookPrimary(book.ISBN, file.tellp()); // -> Add to primary index file\r\n                insertAuthorID(book.authorID, book.ISBN); // -> Add to secondary file\r\n\r\n                file << recSize << book.ISBN << '|' << book.bookTitle << '|' << book.authorID << '|';\r\n\r\n                file.close();\r\n                cout << \"The record is added successfully!\" << endl;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid deleteBookPrimary(char id[]){\r\n    int x = atoi(id);\r\n\r\n    // Delete from PrimaryIndexBook.txt\r\n    vector<pair<int, int>> data;\r\n    ifstream readPrimary(\"PrimaryIndexBook.txt\");\r\n    int ID, of;\r\n\r\n    while (readPrimary >> ID >> of) {\r\n        if (ID != x)\r\n            data.push_back(make_pair(ID, of));\r\n    }\r\n    readPrimary.close();\r\n\r\n    ofstream writePrimary(\"PrimaryIndexBook.txt\", ios::trunc);\r\n\r\n    for (int i = 0; i < data.size(); ++i) {\r\n        writePrimary << data[i].first << ' ' << data[i].second << '\\n';\r\n    }\r\n    writePrimary.close();\r\n}\r\n\r\nvoid deleteAuthorPrimary(char id[]){\r\n    int x = stoi(id);\r\n\r\n    vector<pair<int , int>> data;\r\n    ifstream readPrimary(\"PrimaryIndexAuthor.txt\");\r\n    int ID , of;\r\n    while(readPrimary >> ID >> of){\r\n        if (ID != x)\r\n            data.push_back(make_pair(ID, of));\r\n    }\r\n    readPrimary.close();\r\n\r\n\r\n    ofstream writePrimary(\"PrimaryIndexAuthor.txt\");\r\n    for(int i = 0 ; i < data.size(); i++){\r\n        writePrimary << data[i].first << ' ' << data[i].second << '\\n';\r\n    }\r\n    writePrimary.close();\r\n}\r\n\r\nvoid deleteAuthorID(char authorID[]) {\r\n    vector<pair<string, string>> data;\r\n\r\n    ifstream secFile(\"SecondaryIndexBook.txt\");\r\n    ifstream llFile(\"LLBook.txt\");\r\n\r\n    string ID, isbn;\r\n    int secPointer, llPointer, x;\r\n\r\n    while (secFile >> ID >> secPointer) {\r\n        llFile.clear();\r\n        llFile.seekg(0, ios::beg);\r\n\r\n        while (llFile >> llPointer >> isbn >> x) {\r\n            if (secPointer == llPointer && ID != authorID) {\r\n                data.push_back(make_pair(ID, isbn));\r\n\r\n                while (x != -1) {\r\n                    llFile >> llPointer >> isbn >> x;\r\n                    data.push_back(make_pair(ID, isbn));\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    secFile.close();\r\n    llFile.close();\r\n\r\n    // Update llFile1 directly using the data vector\r\n    ofstream llFile1(\"LLBook.txt\", ios::trunc);\r\n\r\n    for (int i = 0; i < data.size(); ++i) {\r\n        if (i < data.size() - 1 && data[i].first == data[i + 1].first)\r\n            llFile1 << i << ' ' << data[i].second << ' ' << i + 1 << '\\n';\r\n        else\r\n            llFile1 << i << ' ' << data[i].second << ' ' << -1 << '\\n';\r\n    }\r\n\r\n    llFile1.close();\r\n\r\n    ofstream secFile1(\"SecondaryIndexBook.txt\", ios::trunc);\r\n\r\n    for (int i = 0; i < data.size(); ++i) {\r\n        if (i == 0 || data[i].first != data[i - 1].first)\r\n            secFile1 << data[i].first << ' ' << i << '\\n';\r\n    }\r\n\r\n    secFile1.close();\r\n\r\n//    for (int i = 0; i < data.size(); ++i) {\r\n//        cout << data[i].first << ' ' << data[i].second << '\\n';\r\n//    }\r\n}\r\n\r\nvoid deleteAuthorName(char name[] , char id[]) {\r\n    vector<pair<string, string>> data;\r\n\r\n    ifstream secFile(\"SecondaryIndexAuthor.txt\");\r\n    ifstream llFile(\"LLAuthor.txt\");\r\n\r\n    string n, ID;\r\n    int secPointer, llPointer, x;\r\n\r\n    // Loop through records in SecondaryIndexAuthor.txt\r\n    while (secFile >> n >> secPointer) {\r\n        llFile.clear();\r\n        llFile.seekg(0, ios::beg);\r\n\r\n        // Match found in SecondaryIndexAuthor.txt\r\n        while (llFile >> llPointer >> ID >> x) {\r\n            if (secPointer == llPointer) {\r\n                if(ID != id){\r\n                    data.push_back(make_pair(n, ID));\r\n                }\r\n\r\n                // If x is not -1, continue pushing IDs until x is -1\r\n                while (x != -1) {\r\n                    llFile >> llPointer >> ID >> x;\r\n                    if(ID != id)\r\n                        data.push_back(make_pair(n, ID));\r\n                }\r\n\r\n                break; // Stop after processing IDs with x = -1\r\n            }\r\n        }\r\n    }\r\n\r\n    secFile.close();\r\n    llFile.close();\r\n\r\n    // Update llFile1 directly using the data vector\r\n    ofstream llFile1(\"LLAuthor.txt\", ios::trunc);\r\n\r\n    for (int i = 0; i < data.size(); ++i) {\r\n        if (i < data.size() - 1 && data[i].first == data[i + 1].first)\r\n            llFile1 << i << ' ' << data[i].second << ' ' << i + 1 << '\\n';\r\n        else\r\n            llFile1 << i << ' ' << data[i].second << ' ' << -1 << '\\n';\r\n    }\r\n\r\n    llFile1.close();\r\n\r\n    ofstream secFile1(\"SecondaryIndexAuthor.txt\", ios::trunc);\r\n\r\n    for (int i = 0; i < data.size(); ++i) {\r\n        if (i == 0 || data[i].first != data[i - 1].first)\r\n            secFile1 << data[i].first << ' ' << i << '\\n';\r\n    }\r\n\r\n    secFile1.close();\r\n\r\n}\r\n\r\nvoid deleteAuthor(char authorID[]) {\r\n    fstream primary(\"PrimaryIndexAuthor.txt\");\r\n    int ID = stoi(authorID);\r\n    if (getAuthorByID(ID , primary) == -1) {\r\n        cout << \"ID doesn't exist!\" << endl;\r\n        return;\r\n    }\r\n    primary.close();\r\n\r\n    if(primary.tellg() == 0){\r\n        cout << \"File is empty!\" << endl;\r\n        return;\r\n    }\r\n\r\n    // Opening the file in read/write mode\r\n    fstream Author(\"Author.txt\", ios::in | ios::out | ios::binary);\r\n\r\n    string header;\r\n//    string line;\r\n\r\n//     Reading the first two lines from the file\r\n    for (int i = 0; i < 2; ++i) {\r\n        if (i == 0)\r\n            Author >> header; // Reading header\r\n//        else\r\n//            Author >> line; // Reading the second line\r\n    }\r\n\r\n\r\n        // it is the first deleted author\r\n        // so we will delete the record and update the header\r\n        // i need to know the offset of the record to be deleted\r\n        // i need to know the size of the record to be deleted\r\n        // so the deleted record will be overwritten with #header|size of the deleted record| and the rest of the record will be spaces\r\n        // then the header will be updated with the offset of the deleted record\r\n        // seek to the record to be deleted\r\n\r\n\r\n        Author.seekp(0, ios::end);\r\n\r\n        fstream primary1(\"PrimaryIndexAuthor.txt\");\r\n        int offset = getAuthorByID(ID , primary1);\r\n        primary1.close();\r\n\r\n\r\n        Author.seekg(offset , ios::beg);\r\n        char name[30];\r\n        while(Author.peek() != '|'){\r\n            Author.seekg(1 , ios::cur);\r\n        }\r\n        Author.seekg(1 , ios::cur); //to skip the |\r\n        Author.getline(name , 30 , '|');\r\n        deleteAuthorName(name , authorID);\r\n\r\n        //know the size of the record to be deleted\r\n        //it is the two digits before the offset\r\n        //seek to the offset\r\n        //and store the these two digits in a variable\r\n\r\n        Author.seekg(offset , ios::beg);\r\n        char size[3];\r\n        Author >> size;\r\n        size[2] = '\\0';\r\n        int sizeOfRecord;\r\n        for(int i = 0 ; i < 2 ; i++){\r\n            sizeOfRecord = sizeOfRecord * 10 + (size[i] - '0');\r\n        }\r\n\r\n\r\n        //update the record with #header|size of the deleted record|\r\n        Author.seekg(offset , ios::beg);\r\n\r\n        Author << '#' << header << '|' << sizeOfRecord << '|';\r\n\r\n        //152|Mohamed|Alex|\r\n        //#-1|15|----------\r\n//        fill the rest of the record with spaces\r\n        for(int i = 0 ; i < sizeOfRecord - 3 - header.size() ; i++){\r\n            Author << ' ';\r\n        }\r\n\r\n        Author.seekp(0 , ios::beg);\r\n        for (int i = 0; i < header.length(); ++i) {\r\n            Author<<' ';\r\n        }\r\n\r\n        //update the header with the offset of this record\r\n        header = to_string(offset);\r\n\r\n        Author.seekp(0 , ios::beg);\r\n        Author << header;\r\n\r\n\r\n        deleteAuthorPrimary(authorID);\r\n\r\n    sizeOfRecord = 0;\r\n    Author.close();\r\n    cout << \"The record is deleted successfully!\" << endl;\r\n\r\n\r\n}\r\n\r\nvoid deleteBook(char ISBN[]) {\r\n    fstream primary(\"PrimaryIndexBook.txt\");\r\n    int isbn = stoi(ISBN);\r\n    if (getBookByISBN(isbn , primary) == -1) {\r\n        cout << \"isbn doesn't exist!\" << endl;\r\n        return;\r\n    }\r\n    primary.close();\r\n\r\n    if(primary.tellg() == 0){\r\n        cout << \"File is empty!\" << endl;\r\n        return;\r\n    }\r\n\r\n    // Opening the file in read/write mode\r\n    fstream Book(\"Book.txt\", ios::in | ios::out | ios::binary);\r\n\r\n    string header;\r\n//    string line;\r\n\r\n//     Reading the first two lines from the file\r\n    for (int i = 0; i < 2; ++i) {\r\n        if (i == 0)\r\n            Book >> header; // Reading header\r\n//        else\r\n//            Author >> line; // Reading the second line\r\n    }\r\n\r\n\r\n    // it is the first deleted author\r\n    // so we will delete the record and update the header\r\n    // i need to know the offset of the record to be deleted\r\n    // i need to know the size of the record to be deleted\r\n    // so the deleted record will be overwritten with #header|size of the deleted record| and the rest of the record will be spaces\r\n    // then the header will be updated with the offset of the deleted record\r\n    // seek to the record to be deleted\r\n\r\n    Book.seekp(0, ios::end);\r\n\r\n    fstream primary1(\"PrimaryIndexBook.txt\");\r\n    int offset = getBookByISBN(isbn , primary1);\r\n    primary1.close();\r\n\r\n\r\n    Book.seekg(offset , ios::beg);\r\n    char id[30];\r\n    while(Book.peek() != '|'){\r\n        Book.seekg(1 , ios::cur);\r\n    }\r\n    Book.seekg(1 , ios::cur); //to skip the |\r\n    while(Book.peek() != '|'){\r\n        Book.seekg(1 , ios::cur);\r\n    }\r\n    Book.seekg(1 , ios::cur); //to skip the |\r\n    Book.getline(id , 30 , '|');\r\n    deleteAuthorID(id);\r\n\r\n    //know the size of the record to be deleted\r\n    //it is the two digits before the offset\r\n    //seek to the offset -2\r\n    //and store the these two digits in a variable\r\n\r\n    Book.seekg(offset , ios::beg);\r\n    char size[3];\r\n    Book >> size;\r\n    size[2] = '\\0';\r\n    int sizeOfRecord;\r\n    for(int i = 0 ; i < 2 ; i++){\r\n        sizeOfRecord = sizeOfRecord * 10 + (size[i] - '0');\r\n    }\r\n    string formatedSize = formatTwoBytes(sizeOfRecord);\r\n\r\n\r\n    //update the record with #header|size of the deleted record|\r\n    Book.seekg(offset , ios::beg);\r\n\r\n    Book << '#' << header << '|' << formatedSize << '|';\r\n\r\n\r\n//        fill the rest of the record with spaces\r\n    for(int i = 0 ; i < sizeOfRecord - 3 - header.size() ; i++){\r\n        Book << ' ';\r\n    }\r\n    //update the header with the offset of this record\r\n    header = to_string(offset);\r\n\r\n    Book.seekp(0 , ios::beg);\r\n    Book << header;\r\n\r\n    deleteBookPrimary(ISBN);\r\n\r\n    sizeOfRecord = 0;\r\n    Book.close();\r\n    cout << \"The record is deleted successfully!\" << endl;\r\n\r\n}\r\nvoid updateAuthorNameByID(int id, string newName, fstream &indexFile) {\r\n\r\n    // search for the author by id and print the author record\r\n    int offset = getAuthorByID(id, indexFile);\r\n\r\n    if (offset != -1) {//author is found\r\n\r\n        ifstream author(\"Author.txt\", ios::binary);\r\n\r\n        // seek to the offset\r\n        author.seekg(offset, ios::beg);\r\n\r\n        // read the length of the author record\r\n        char length[3];\r\n        length[2] = '\\0';\r\n        author.read(length, 2);//read 2 bytes\r\n\r\n        // convert the length to integer\r\n        int len = stoi(length);\r\n\r\n        // read about len bytes from the current position\r\n        char *record = new char[len + 1];\r\n        record[len] = '\\0';//\r\n        author.read(record, len);\r\n        author.close();\r\n\r\n        // parse the record\r\n        stringstream ss(record);\r\n        string ID, name, address;\r\n        getline(ss, ID, '|');\r\n        getline(ss, name, '|');\r\n        getline(ss, address, '|');\r\n\r\n        // update code\r\n        string newRecord = ID + \"|\" + newName + \"|\" + address + \"|\";\r\n\r\n        if (newRecord != record) {\r\n\r\n            // printing old record\r\n            cout << \"Old Record is: \" << endl;\r\n            cout << record << endl;\r\n\r\n            fstream author2(\"Author.txt\", ios::in | ios::out);\r\n\r\n            // I work as I use fixed fields\r\n\r\n\r\n//              // if she wants to update the author name in secondary file, so I will use add, delete functions\r\n//\r\n//                    Author a;\r\n//                    strcpy(a.authorID, ID.c_str());\r\n//                    strcpy(a.authorName, newName.c_str());\r\n//                    strcpy(a.address, address.c_str());\r\n//\r\n//                    author2.close();\r\n//                    char id[30];\r\n//                    for (int i = 0; i < 30; i++) {\r\n//                        id[i] = a.authorID[i];\r\n//                    }\r\n//                    deleteAuthor(id);\r\n//                    addAuthor(a);\r\n//\r\n//                    cout << \"Author name is updated successfully!\" << endl;\r\n//                    cout << \"New Record is: \" << endl;\r\n//                    cout << ID << \"|\" << newName << \"|\" << address << \"|\" << endl;\r\n\r\n\r\n\r\n            if (newName.length() <= 30) {      //new name is valid\r\n\r\n                if (name.length() == newName.length()) {    //new name has the same length as the old one\r\n\r\n                    author2.seekp(offset + ID.size() + 3, ios::beg);  //seek to the name field\r\n                    author2 << newName; // update the name\r\n                    author2.close();\r\n\r\n                    cout << \"Author name is updated successfully!\" << endl;\r\n                    cout << \"New Record is: \" << endl;\r\n                    cout << ID << \"|\" << newName << \"|\" << address << \"|\" << endl;\r\n\r\n                } else if (name.length() > newName.length()) { //new name is shorter than the old one\r\n\r\n                    author2.seekp(offset + ID.size() + 3, ios::beg); //seek to the name field\r\n                    author2 << newName;// update the name\r\n\r\n                    for (int i = 0; i < name.length() - newName.length(); ++i){ //fill the rest of the field with '-'\r\n                        author2 << \"-\";\r\n                    }\r\n\r\n                    author2.close();\r\n                    cout << \"Author name is updated successfully!\" << endl;\r\n                    cout << \"New Record is: \" << endl;\r\n                    cout << ID << \"|\" << newName;\r\n\r\n                    //print the rest of the field-> ex: shahd--\r\n                    for (int i = 0; i < name.length() - newName.length(); ++i) {\r\n                        cout << \"-\";\r\n                    }\r\n                    cout << \"|\" << address << \"|\" << endl;\r\n\r\n                } else {     //name.length()<newName.length()\r\n                    author2.close();\r\n                    cout << \"\\\"We use internal fragmentation with Fixed Fields\\\": new name is longer than the old one!\" << endl;\r\n                }\r\n            } else { //new name is too long (not valid)\r\n                author2.close();\r\n                cout << \"Author name is too long!\" << endl;\r\n            }\r\n            author2.close();\r\n        } else {\r\n            cout<<\"Same record!\"<<endl;\r\n        }\r\n    }else{\r\n        cout << \"Author is NOT found!\" << endl;\r\n    }\r\n}\r\n\r\nvoid updateBookTitleByISBN(int isbn, string newTitle, fstream &indexFile) {\r\n    // search for the book by isbn and print the book record\r\n    int offset = getBookByISBN(isbn, indexFile);\r\n\r\n    if (offset != -1) {// book is found\r\n\r\n        ifstream book(\"Book.txt\", ios::binary);\r\n\r\n        // seek to the offset\r\n        book.seekg(offset, ios::beg);\r\n\r\n        // read the length of the book record\r\n        char length[3];\r\n        length[2] = '\\0';\r\n        book.read(length, 2);\r\n\r\n        // convert the length to integer\r\n        int len = stoi(length);\r\n        char *record = new char[len + 1]; // read about len bytes from the current position\r\n        record[len] = '\\0';\r\n        book.read(record, len);\r\n        book.close();\r\n\r\n        // parse the record\r\n        stringstream ss(record);\r\n        string ISBN, title, authorID;\r\n        getline(ss, ISBN, '|');\r\n        getline(ss, title, '|');\r\n        getline(ss, authorID, '|');\r\n\r\n\r\n        // update code\r\n\r\n        string newRecord = ISBN + \"|\" + newTitle + \"|\" + authorID + \"|\";\r\n        if (newRecord != record) {\r\n\r\n            // printing old record\r\n            cout << \"Old Record is: \" << endl;\r\n            cout << record << endl;\r\n\r\n            fstream book2(\"Book.txt\", ios::in | ios::out);\r\n\r\n\r\n            // I work as I use fixed fields\r\n\r\n\r\n            if (newTitle.length() <= 30) { //new title is valid\r\n\r\n                if (title.length() == newTitle.length()) {//new title has the same length as the old one\r\n\r\n                    book2.seekp(offset + ISBN.size() + 3, ios::beg);//seek to the title field\r\n                    book2 << newTitle;\r\n                    book2.close();\r\n                    cout << \"Book title is updated successfully!\" << endl;\r\n                    cout << ISBN << \"|\" << newTitle << \"|\" << authorID << \"|\" << endl;\r\n\r\n                } else if (title.length() > newTitle.length()) {//new title is shorter than the old one\r\n\r\n                    book2.seekp(offset + ISBN.size() + 3, ios::beg);//seek to the title field\r\n                    book2 << newTitle;\r\n\r\n                    for (int i = 0; i < title.length() - newTitle.length(); ++i) {//fill the rest of the field with '-'\r\n                        book2 << \"-\";\r\n                    }\r\n                    book2.close();\r\n                    cout << \"Book title is updated successfully!\" << endl;\r\n                    cout << ISBN << \"|\" << newTitle;\r\n\r\n                    for (int i = 0;\r\n                         i < title.length() - newTitle.length(); i++)//print the rest of the field-> ex: Book--\r\n                        cout << \"-\";\r\n                    cout << \"|\" << authorID << \"|\" << endl;\r\n\r\n                } else { //title.length()<newTitle.length()\r\n\r\n\r\n                    /*      // if she wants to update the book title with large size, so I will use add, delete functions\r\n\r\n                              Book b;\r\n                              strcpy(b.ISBN, ISBN.c_str());\r\n                              strcpy(b.bookTitle, newTitle.c_str());\r\n                              strcpy(b.authorID, authorID.c_str());\r\n\r\n                              book2.close();\r\n\r\n                              author2.close();\r\n                              char isbn[30];\r\n                              for (int i = 0; i < 30; i++) {\r\n                                  isbn[i] = b.ISBN[i];\r\n                              }\r\n                              deleteAuthor(id);\r\n                              addAuthor(b);\r\n\r\n                              cout << \"Book title is updated successfully!\" << endl;\r\n                              cout<<\"New Record is: \"<<endl;\r\n                              cout << ISBN << \"|\" << newTitle << \"|\" << authorID << \"|\" << endl;\r\n                  */\r\n\r\n                    cout << \"\\\"We use internal fragmentation with Fixed Fields\\\": new title is longer than the old one!\"\r\n                         << endl;\r\n                }\r\n            } else { //new title is too long (not valid)\r\n                cout << \"Book title is too long!\" << endl;\r\n            }\r\n        } else {\r\n            cout << \"Same record!\" << endl;\r\n        }\r\n    }else{\r\n        cout<<\"Book is NOT found!\"<<endl;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.cpp b/main.cpp
--- a/main.cpp	(revision bd701dd6a800b3a3882330fb02e57c9198d0fe93)
+++ b/main.cpp	(date 1701977831025)
@@ -43,6 +43,7 @@
 void deleteBook(char ISBN[]);
 
 
+
 int getAuthorByID(int id, fstream &indexFile); // search for the author by id
 int getBookByISBN(int isbn, fstream &indexFile); // search for the book by isbn
 void printAuthorByID(int offset); // print the author record by offset
@@ -1356,6 +1357,9 @@
 
     secFile1.close();
 
+    for (int i = 0; i < data.size(); ++i) {
+        cout << data[i].first << ' ' << data[i].second << '\n';
+    }
 }
 
 void deleteAuthor(char authorID[]) {
